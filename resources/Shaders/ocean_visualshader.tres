[gd_resource type="VisualShader" load_steps=50 format=3 uid="uid://buh5ms3vm1n7"]

[ext_resource type="Script" path="res://addons/visual_shader_node_library/shader_nodes/3d/screenspace_refraction.gd" id="1"]
[ext_resource type="Script" path="res://addons/visual_shader_node_library/shader_nodes/common/noise/simplex_3d.gd" id="2"]
[ext_resource type="Script" path="res://addons/shaderV/tools/TimeScaled.gd" id="4"]

[sub_resource type="VisualShaderNodeInput" id="1"]
output_port_for_preview = 0
input_name = "uv"

[sub_resource type="VisualShaderNodeVectorOp" id="2"]
operator = 2

[sub_resource type="VisualShaderNodeFloatParameter" id="3"]
parameter_name = "Normal_Resolution"

[sub_resource type="VisualShaderNodeVectorOp" id="4"]

[sub_resource type="VisualShaderNodeCustom" id="5"]
default_input_values = [0, 0.1]
initialized = true
script = ExtResource("4")

[sub_resource type="VisualShaderNodeVectorCompose" id="6"]

[sub_resource type="VisualShaderNodeFloatOp" id="7"]
default_input_values = [0, 0.0, 1, -1.0]
operator = 2

[sub_resource type="VisualShaderNodeVec3Parameter" id="49"]
parameter_name = "uv_aspectratio"

[sub_resource type="VisualShaderNodeVectorOp" id="50"]
operator = 2

[sub_resource type="VisualShaderNodeTexture2DParameter" id="VisualShaderNodeTexture2DParameter_vly2v"]
parameter_name = "screen_text"
texture_filter = 4
texture_source = 1

[sub_resource type="VisualShaderNodeTexture2DParameter" id="VisualShaderNodeTexture2DParameter_wo80b"]
parameter_name = "depth_text"
texture_type = 1
texture_filter = 1
texture_repeat = 2
texture_source = 2

[sub_resource type="VisualShaderNodeTexture" id="VisualShaderNodeTexture_d387j"]
source = 5

[sub_resource type="VisualShaderNodeVectorDecompose" id="VisualShaderNodeVectorDecompose_0baoi"]
default_input_values = [0, Quaternion(0, 0, 0, 0)]
op_type = 2

[sub_resource type="VisualShaderNodeInput" id="VisualShaderNodeInput_svam0"]
input_name = "inv_projection_matrix"

[sub_resource type="VisualShaderNodeExpression" id="VisualShaderNodeExpression_kf1ub"]
size = Vector2(792.119, 502.087)
expression = "vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, depth);
vec4 view = matrix * vec4(ndc, 1.0);
view.xyz /= view.w;
linear_depth = view.z;"

[sub_resource type="VisualShaderNodeInput" id="VisualShaderNodeInput_suofc"]
input_name = "vertex"

[sub_resource type="VisualShaderNodeVectorDecompose" id="VisualShaderNodeVectorDecompose_r5c3m"]

[sub_resource type="VisualShaderNodeFloatOp" id="VisualShaderNodeFloatOp_xjae2"]
operator = 1

[sub_resource type="VisualShaderNodeFloatOp" id="VisualShaderNodeFloatOp_f51ga"]
operator = 2

[sub_resource type="VisualShaderNodeFloatOp" id="VisualShaderNodeFloatOp_msonu"]
default_input_values = [0, 1.0, 1, 0.0]
operator = 1

[sub_resource type="VisualShaderNodeFloatConstant" id="8"]

[sub_resource type="VisualShaderNodeColorParameter" id="9"]
parameter_name = "Albedo"

[sub_resource type="VisualShaderNodeCustom" id="10"]
default_input_values = [1, 1.0, 2, 0.0, 4, 0.0]
initialized = true
script = ExtResource("1")

[sub_resource type="VisualShaderNodeFloatParameter" id="11"]
parameter_name = "IOR"

[sub_resource type="VisualShaderNodeColorConstant" id="12"]
constant = Color(1, 1, 1, 0)

[sub_resource type="VisualShaderNodeInput" id="13"]
input_name = "screen_uv"

[sub_resource type="VisualShaderNodeTexture" id="14"]
source = 5

[sub_resource type="VisualShaderNodeFloatConstant" id="16"]
constant = 0.3

[sub_resource type="VisualShaderNodeMix" id="17"]
default_input_values = [0, Vector3(0, 0, 0), 1, Vector3(1, 1, 1), 2, Vector3(0, 0, 0)]
op_type = 3

[sub_resource type="VisualShaderNodeMix" id="18"]
default_input_values = [0, Vector3(0, 0, 0), 1, Vector3(0, 0, 0), 2, Vector3(0, 0, 0)]
op_type = 3

[sub_resource type="VisualShaderNodeClamp" id="28"]
default_input_values = [0, 1.0, 1, 0.15, 2, 1.0]

[sub_resource type="VisualShaderNodeFloatParameter" id="29"]
parameter_name = "Depth_Scale"

[sub_resource type="VisualShaderNodeFloatConstant" id="30"]
constant = 1.0

[sub_resource type="VisualShaderNodeTexture2DParameter" id="32"]
parameter_name = "TextureUniform"
texture_type = 2

[sub_resource type="VisualShaderNodeFloatOp" id="34"]
default_input_values = [0, 0.0, 1, 2.0]
operator = 2

[sub_resource type="VisualShaderNodeFloatConstant" id="35"]
constant = 100.0

[sub_resource type="VisualShaderNodeInput" id="36"]
input_name = "uv"

[sub_resource type="VisualShaderNodeCustom" id="37"]
default_input_values = [1, Vector3(1, 1, 1)]
initialized = true
script = ExtResource("2")

[sub_resource type="VisualShaderNodeCustom" id="38"]
default_input_values = [0, 0.01]
initialized = true
script = ExtResource("4")

[sub_resource type="VisualShaderNodeVectorOp" id="39"]
default_input_values = [0, Vector3(0, 0, 0), 1, Vector3(2, 3, 3)]
operator = 2

[sub_resource type="VisualShaderNodeFloatParameter" id="47"]
parameter_name = "Wave_Height"

[sub_resource type="VisualShaderNodeFloatOp" id="51"]
default_input_values = [0, 0.0, 1, 1.0]
operator = 1

[sub_resource type="VisualShaderNodeInput" id="42"]
input_name = "vertex"

[sub_resource type="VisualShaderNodeVectorDecompose" id="43"]

[sub_resource type="VisualShaderNodeVectorCompose" id="44"]

[sub_resource type="VisualShaderNodeFloatOp" id="45"]

[resource]
code = "shader_type spatial;
render_mode blend_mix, depth_draw_opaque, cull_back, diffuse_lambert, specular_schlick_ggx;

uniform float Wave_Height;
uniform vec4 Albedo : source_color;
uniform float IOR;
uniform sampler2D screen_text : filter_linear_mipmap, hint_screen_texture;
uniform sampler2D depth_text : source_color, filter_nearest, repeat_disable, hint_depth_texture;
uniform float Depth_Scale;
uniform vec3 uv_aspectratio;
uniform float Normal_Resolution;
uniform sampler2D TextureUniform : hint_normal;


// SimplexNoise3D


// Description : Array and textureless GLSL 2D/3D/4D simplex 
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
// 

vec3 HELPER_SimplexNoise3D_mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_SimplexNoise3D_mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_SimplexNoise3D_permute(vec4 x) {
    return HELPER_SimplexNoise3D_mod289_4(((x*34.0)+1.0)*x);
}

vec4 HELPER_SimplexNoise3D_taylorInvSqrt(vec4 r) {
    return 2.79284291400159 - 0.85373472095314 * r;
}

float simplex_noise_3d(vec3 v, out vec3 gradient) {
    vec2 C = vec2(1.0/6.0, 1.0/3.0) ;
    vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    
    // First corner
    vec3 i  = floor(v + dot(v, vec3(C.y)) );
    vec3 x0 =   v - i + dot(i, vec3(C.x)) ;
    
    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );
    
    //   x0 = x0 - 0.0 + 0.0 * C.xxx;
    //   x1 = x0 - i1  + 1.0 * C.xxx;
    //   x2 = x0 - i2  + 2.0 * C.xxx;
    //   x3 = x0 - 1.0 + 3.0 * C.xxx;
    vec3 x1 = x0 - i1 + vec3(C.x);
    vec3 x2 = x0 - i2 + vec3(C.y); // 2.0*C.x = 1/3 = C.y
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
    
    // Permutations
    i = HELPER_SimplexNoise3D_mod289_3(i); 
    vec4 p = HELPER_SimplexNoise3D_permute( HELPER_SimplexNoise3D_permute( HELPER_SimplexNoise3D_permute( 
    		 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
    	   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
    	   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
    
    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
    float n_ = 0.142857142857; // 1.0/7.0
    vec3  ns = n_ * D.wyz - D.xzx;
    
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
    
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
    
    vec4 x = x_ *ns.x + vec4(ns.y);
    vec4 y = y_ *ns.x + vec4(ns.y);
    vec4 h = 1.0 - abs(x) - abs(y);
    
    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );
    
    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    
    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;
    
    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);
    
    //Normalise gradients
    vec4 norm = HELPER_SimplexNoise3D_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    
    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), vec4(0.0));
    vec4 m2 = m * m;
    vec4 m4 = m2 * m2;
    vec4 pdotx = vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3));
    
    // Determine noise gradient
    vec4 temp = m2 * m * pdotx;
    gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);
    gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;
    gradient *= 42.0;
    
    return 22.0 * dot(m4, pdotx);
}

// ScreenSpaceRefraction

const int SSR_MAX_STEPS = 256;

vec3 line_plane_intersect(vec3 lineorigin, vec3 linedirection, vec3 planeorigin, vec3 planenormal) {
	float dist = dot(planenormal, planeorigin - lineorigin) / dot(planenormal, linedirection);
	return lineorigin + linedirection * dist;
}

float line_unit_box_intersect_dist(vec3 lineorigin, vec3 linedirection) {
  /* https://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/
   */
  vec3 firstplane = (vec3(1.0) - lineorigin) / linedirection;
  vec3 secondplane = (vec3(-1.0) - lineorigin) / linedirection;
  vec3 furthestplane = max(firstplane, secondplane);

  return min(furthestplane.x, min(furthestplane.y, furthestplane.z));
}

vec3 project_point(mat4 projection_matrix, vec3 point) {
	vec4 ndc = projection_matrix * vec4(point, 1.0);
	return ndc.xyz / ndc.w;
}

float F_eta(float eta, float cos_theta) {
	/* compute fresnel reflectance without explicitly computing
	* the refracted direction */
	float c = abs(cos_theta);
	float g = eta * eta - 1.0 + c * c;
	float result;
	
	if (g > 0.0) {
		g = sqrt(g);
		vec2 g_c = vec2(g) + vec2(c, -c);
		float A = g_c.y / g_c.x;
		A *= A;
		g_c *= c;
		float B = (g_c.y - 1.0) / (g_c.x + 1.0);
		B *= B;
		result = 0.5 * A * (1.0 + B);
	} else {
		result = 1.0; /* TIR (no refracted component) */
	}
	
	return result;
}

void prepare_raycast(mat4 projection_matrix, vec3 ray_origin, vec3 ray_dir, float ssr_thickness, vec2 pixel_size, out vec4 ss_step, out vec4 ss_ray, out float max_time) {
	/* Negate the ray direction if it goes towards the camera.
	* This way we don't need to care if the projected point
	* is behind the near plane. */
	float z_sign = -sign(ray_dir.z);
	vec3 ray_end = ray_origin + z_sign * ray_dir;
	
	/* Project into screen space. */
	vec4 ss_start, ss_end;
	ss_start.xyz = project_point(projection_matrix, ray_origin);
	ss_end.xyz = project_point(projection_matrix, ray_end);
	
	/* We interpolate the ray Z + ssr_thickness values to check if depth is within threshold. */
	ray_origin.z -= ssr_thickness;
	ray_end.z -= ssr_thickness;
	ss_start.w = project_point(projection_matrix, ray_origin).z;
	ss_end.w = project_point(projection_matrix, ray_end).z;
	
	/* XXX This is a hack. A better method is welcome! */
	/* We take the delta between the offsetted depth and the depth and subtract it from the ray
	* depth. This will change the world space ssr_thickness appearance a bit but we can have negative
	* values without worries. We cannot do this in viewspace because of the perspective division. */
	ss_start.w = 2.0 * ss_start.z - ss_start.w;
	ss_end.w = 2.0 * ss_end.z - ss_end.w;
	
	ss_step = ss_end - ss_start;
	max_time = length(ss_step.xyz);
	ss_step = z_sign * ss_step / length(ss_step.xyz);
	
	/* If the line is degenerate, make it cover at least one pixel
	* to not have to handle zero-pixel extent as a special case later */
	ss_step.xy += vec2((dot(ss_step.xy, ss_step.xy) < 0.00001) ? 0.001 : 0.0);
	
	/* Make ss_step cover one pixel. */
	ss_step /= max(abs(ss_step.x), abs(ss_step.y));
	ss_step *= (abs(ss_step.x) > abs(ss_step.y)) ? pixel_size.x : pixel_size.y;
	
	/* Clip to segment's end. */
	max_time /= length(ss_step.xyz);
	
	/* Clipping to frustum sides. */
	max_time = min(max_time, line_unit_box_intersect_dist(ss_start.xyz, ss_step.xyz));
	
	/* Convert to texture coords. Z component included
	* since this is how it's stored in the depth buffer.
	* 4th component how far we are on the ray */
	ss_ray = ss_start * 0.5 + 0.5;
	ss_step *= 0.5;
	
	/* take the center of the texel. */
}

// #define GROUPED_FETCHES /* is still slower, need to see where is the bottleneck. */
/* Return the hit position, and negate the z component (making it positive) if not hit occurred. */
/* __ray_dir__ is the ray direction premultiplied by it's maximum length */
vec3 raycast(mat4 projection_matrix, sampler2D depth_texture, vec3 ray_origin, vec3 ray_dir, float ssr_thickness, float ray_jitter, float trace_quality, float ssr_roughness, bool discard_backface) {
	vec4 ss_step, ss_start;
	float max_time;
	prepare_raycast(projection_matrix, ray_origin, ray_dir, ssr_thickness, 1.0 / vec2(textureSize(depth_texture, 0)), ss_step, ss_start, max_time);
	
	float max_trace_time = max(0.01, max_time - 0.01);
	
	/* x : current_time, y: previous_time, z: current_delta, w: previous_delta */
	vec4 times_and_deltas = vec4(0.0);
	
	float ray_time = 0.0;
	float depth_sample = textureLod(depth_texture, ss_start.xy, 0.0).x;
	times_and_deltas.z = depth_sample - ss_start.z;
	
	float lod_fac = clamp(sqrt(ssr_roughness) * 2.0 - 0.4, 0.0, 1.0);
	bool hit = false;

	for(float iter = 1.0; !hit && (ray_time < max_time) && (iter < float(SSR_MAX_STEPS)); iter++) {
		/* Minimum stride of 2 because we are using half res minmax zbuffer. */
		float stride = max(1.0, iter * trace_quality) * 2.0;
		float lod = log2(stride * 0.5 * trace_quality) * lod_fac;
		ray_time += stride;
		
		/* Save previous values. */
		times_and_deltas.xyzw = times_and_deltas.yxwz;
		
		float jit_stride = mix(2.0, stride, ray_jitter);
		
		times_and_deltas.x = min(ray_time + jit_stride, max_trace_time);
		vec4 ss_ray = ss_start + ss_step * times_and_deltas.x;
		
		depth_sample = textureLod(depth_texture, ss_ray.xy, lod).x;
		
		float prev_w = ss_start.w + ss_step.w * times_and_deltas.y;
		times_and_deltas.z = depth_sample - ss_ray.z;
		hit = (times_and_deltas.z <= 0.0) && (prev_w <= depth_sample);
	}
	
	if (discard_backface) {
		/* Discard backface hits */
		hit = hit && (times_and_deltas.w > 0.0);
	}
	
	/* Reject hit if background. */
	hit = hit && (depth_sample != 1.0);
	
	times_and_deltas.x = hit ? mix(times_and_deltas.y, times_and_deltas.x, clamp(times_and_deltas.w / (times_and_deltas.w - times_and_deltas.z), 0.0, 1.0)) : times_and_deltas.x;
	ray_time = hit ? times_and_deltas.x : ray_time;
	
	/* Clip to frustum. */
	ray_time = max(0.001, min(ray_time, max_time - 1.5));
	
	vec4 ss_ray = ss_start + ss_step * ray_time;
	
	/* Tag Z if ray failed. */
//	ss_ray.z *= (hit) ? 1.0 : -1.0;
	return ss_ray.xyz;
}

float screen_border_mask(vec2 hit_co) {
	const float ssrBorderFac = 0.1;
	
	const float margin = 0.003;
	float atten = ssrBorderFac + margin; /* Screen percentage */
	hit_co = smoothstep(margin, atten, hit_co) * (1.0 - smoothstep(1.0 - atten, 1.0 - margin, hit_co));
	float screenfade = hit_co.x * hit_co.y;
	return screenfade;
}

vec4 ssr(vec3 position, mat4 projection_matrix, mat4 view_matrix, sampler2D screen_texture, sampler2D depth_texture, vec3 N, vec3 V, float ssr_ior, float ssr_roughnessSquared) {
	vec3 H = N;
	
	float eta = 1.0 / ssr_ior;
	if (dot(H, V) < 0.0) {
		H = -H;
		eta = ssr_ior;
	}
	
	vec3 R = refract(-V, H, 1.0 / ssr_ior);
	
	R = (view_matrix * vec4(R, 0.0)).xyz;
	
	const float ssrssr_thickness = 1.0;
	const float ssrQuality = 0.0;
	
	vec3 hit_pos = raycast(projection_matrix, depth_texture, position, R * 1e16, ssrssr_thickness, 0.0, ssrQuality, ssr_roughnessSquared, false);
	
	if ((hit_pos.z > 0.0) && (F_eta(ssr_ior, dot(H, V)) < 1.0)) {
		vec2 hit_uvs = project_point(projection_matrix, hit_pos).xy * 0.5 + 0.5;
		
		vec3 spec = textureLod(screen_texture, hit_pos.xy, ssr_roughnessSquared * 8.0).xyz;
		float mask = screen_border_mask(hit_uvs);
		return vec4(spec, mask);
	}
	
	return vec4(0.0);
}

void screenspace_refraction(in float ssr_ior, in float ssr_roughness, in float ssr_thickness, in vec3 albedo_in, in float alpha_in, in vec3 emission_in, in vec2 screen_uv, in sampler2D screen_texture, in sampler2D depth_texture, in vec3 view, in vec3 normal, in vec3 position, in mat4 view_matrix, in mat4 camera_matrix, in mat4 projection_matrix, out vec3 albedo_out, out vec3 emission_out) { 
	vec3 V = (camera_matrix * vec4(view, 0.0)).xyz;
	vec3 N = (camera_matrix * vec4(normal, 0.0)).xyz;
	vec3 world_pos = (camera_matrix * vec4(position, 1.0)).xyz;
	
	/* Refract the view vector using the depth heuristic.
	* Then later Refract a second time the already refracted
	* ray using the inverse ssr_ior. */
	float final_ior = (ssr_thickness > 0.0) ? 1.0 / ssr_ior : ssr_ior;
	vec3 refr_V = (ssr_thickness > 0.0) ? -refract(-V, N, final_ior) : V;
	vec3 refr_pos = (ssr_thickness > 0.0) ?
			line_plane_intersect(world_pos, refr_V, world_pos - N * ssr_thickness, N) :
			world_pos;
	
	/* ---------------------------- */
	/*   Screen Space Refraction    */
	/* ---------------------------- */
	/* Find approximated position of the 2nd refraction event. */
	vec3 refr_vpos = (ssr_thickness > 0.0) ? (view_matrix * vec4(refr_pos, 1.0)).xyz :
			position;
	vec4 trans = ssr(refr_vpos, projection_matrix, view_matrix, screen_texture, depth_texture, N, refr_V, final_ior, ssr_roughness * ssr_roughness);
	trans.a *= smoothstep(1.0 + 0.2, 1.0, ssr_roughness);
	
	float fac = 1.0 - alpha_in;
	fac *= 1.0 - pow(1.0 - dot(V, N), 5.0) * (1.0 - ssr_roughness);
	
	emission_out = emission_in + trans.rgb * albedo_in * fac;
	albedo_out = albedo_in * 1.0 - fac;
}


void vertex() {
// Input:5
	vec3 n_out5p0 = VERTEX;


// VectorDecompose:6
	float n_out6p0 = n_out5p0.x;
	float n_out6p1 = n_out5p0.y;
	float n_out6p2 = n_out5p0.z;


// Input:14
	vec2 n_out14p0 = UV;


	float n_out18p0;
// ScaledTIME:18
	float n_in18p0 = 0.01000;
	{
		n_out18p0 = n_in18p0 * TIME;
	}


// VectorOp:19
	vec3 n_out19p0 = vec3(n_out14p0, 0.0) * vec3(n_out18p0);


// FloatConstant:13
	float n_out13p0 = 100.000000;


	float n_out15p0;
	vec3 n_out15p1;
// SimplexNoise3D:15
	{
		
				n_out15p0 = simplex_noise_3d(n_out19p0 * vec3(n_out13p0), n_out15p1);
			
	}


// FloatOp:23
	float n_in23p1 = 1.00000;
	float n_out23p0 = n_out15p0 - n_in23p1;


// FloatParameter:22
	float n_out22p0 = Wave_Height;


// FloatOp:11
	float n_out11p0 = n_out23p0 * n_out22p0;


// FloatOp:8
	float n_out8p0 = n_out6p1 + n_out11p0;


// VectorCompose:7
	vec3 n_out7p0 = vec3(n_out6p0, n_out8p0, n_out6p2);


// Output:0
	VERTEX = n_out7p0;


}

void fragment() {
// ColorParameter:18
	vec4 n_out18p0 = Albedo;


// FloatParameter:20
	float n_out20p0 = IOR;


// FloatConstant:17
	float n_out17p0 = 0.000000;


// ColorConstant:26
	vec4 n_out26p0 = vec4(1.000000, 1.000000, 1.000000, 0.000000);


	vec3 n_out19p0;
	vec3 n_out19p1;
// ScreenSpaceRefraction:19
	float n_in19p1 = 1.00000;
	float n_in19p4 = 0.00000;
	{
		screenspace_refraction(n_out20p0, n_out17p0, n_in19p1, vec3(n_out26p0.xyz), n_in19p4, vec3(0.0), SCREEN_UV, screen_text, depth_text, VIEW, NORMAL, VERTEX, VIEW_MATRIX, INV_VIEW_MATRIX, PROJECTION_MATRIX, n_out19p0, n_out19p1);
	}


// FloatParameter:61
	float n_out61p0 = Depth_Scale;


// Input:136
	vec3 n_out136p0 = VERTEX;


// VectorDecompose:137
	float n_out137p0 = n_out136p0.x;
	float n_out137p1 = n_out136p0.y;
	float n_out137p2 = n_out136p0.z;


// Input:133
	mat4 n_out133p0 = INV_PROJECTION_MATRIX;


// Input:33
	vec2 n_out33p0 = SCREEN_UV;


	vec4 n_out35p0;
// Texture2D:35
	n_out35p0 = texture(depth_text, n_out33p0);


// VectorDecompose:125
	float n_out125p0 = n_out35p0.x;
	float n_out125p1 = n_out35p0.y;
	float n_out125p2 = n_out35p0.z;
	float n_out125p3 = n_out35p0.w;


	float n_out134p0;
// Expression:134
	n_out134p0 = 0.0;
	{
		vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, n_out125p0);
		vec4 view = n_out133p0 * vec4(ndc, 1.0);
		view.xyz /= view.w;
		n_out134p0 = view.z;
	}


// FloatOp:138
	float n_out138p0 = n_out137p2 - n_out134p0;


// FloatOp:139
	float n_out139p0 = n_out61p0 * n_out138p0;


// FloatOp:140
	float n_in140p0 = 1.00000;
	float n_out140p0 = n_in140p0 - n_out139p0;


// Clamp:59
	float n_in59p1 = 0.15000;
	float n_in59p2 = 1.00000;
	float n_out59p0 = clamp(n_out140p0, n_in59p1, n_in59p2);


// Mix:40
	vec3 n_out40p0 = mix(vec3(n_out18p0.xyz), n_out19p0, vec3(n_out59p0));


// FloatConstant:39
	float n_out39p0 = 0.300000;


// Mix:41
	vec3 n_in41p0 = vec3(0.00000, 0.00000, 0.00000);
	vec3 n_out41p0 = mix(n_in41p0, n_out19p1, vec3(n_out59p0));


// Input:100
	vec2 n_out100p0 = UV;


// Vector3Parameter:107
	vec3 n_out107p0 = uv_aspectratio;


// VectorOp:108
	vec3 n_out108p0 = vec3(n_out100p0, 0.0) * n_out107p0;


// FloatParameter:102
	float n_out102p0 = Normal_Resolution;


// VectorOp:101
	vec3 n_out101p0 = n_out108p0 * vec3(n_out102p0);


	float n_out104p0;
// ScaledTIME:104
	float n_in104p0 = 0.10000;
	{
		n_out104p0 = n_in104p0 * TIME;
	}


// FloatOp:106
	float n_in106p1 = -1.00000;
	float n_out106p0 = n_out104p0 * n_in106p1;


// VectorCompose:105
	float n_in105p2 = 0.00000;
	vec3 n_out105p0 = vec3(n_out104p0, n_out106p0, n_in105p2);


// VectorOp:103
	vec3 n_out103p0 = n_out101p0 + n_out105p0;


	vec4 n_out111p0;
// Texture2D:111
	n_out111p0 = texture(TextureUniform, vec2(n_out103p0.xy));


// FloatConstant:95
	float n_out95p0 = 1.000000;


// Output:0
	ALBEDO = n_out40p0;
	ROUGHNESS = n_out39p0;
	EMISSION = n_out41p0;
	NORMAL_MAP = vec3(n_out111p0.xyz);
	NORMAL_MAP_DEPTH = n_out95p0;


}
"
nodes/vertex/0/position = Vector2(2720, -520)
nodes/vertex/5/node = SubResource("42")
nodes/vertex/5/position = Vector2(-560, -120)
nodes/vertex/6/node = SubResource("43")
nodes/vertex/6/position = Vector2(-140, -240)
nodes/vertex/7/node = SubResource("44")
nodes/vertex/7/position = Vector2(2240, -440)
nodes/vertex/8/node = SubResource("45")
nodes/vertex/8/position = Vector2(1080, -220)
nodes/vertex/11/node = SubResource("34")
nodes/vertex/11/position = Vector2(720, -80)
nodes/vertex/13/node = SubResource("35")
nodes/vertex/13/position = Vector2(-1060, 420)
nodes/vertex/14/node = SubResource("36")
nodes/vertex/14/position = Vector2(-1840, -120)
nodes/vertex/15/node = SubResource("37")
nodes/vertex/15/position = Vector2(-580, 120)
nodes/vertex/18/node = SubResource("38")
nodes/vertex/18/position = Vector2(-2080, 300)
nodes/vertex/19/node = SubResource("39")
nodes/vertex/19/position = Vector2(-1420, 0)
nodes/vertex/22/node = SubResource("47")
nodes/vertex/22/position = Vector2(220, 200)
nodes/vertex/23/node = SubResource("51")
nodes/vertex/23/position = Vector2(260, -60)
nodes/vertex/connections = PackedInt32Array(5, 0, 6, 0, 6, 0, 7, 0, 6, 2, 7, 2, 6, 1, 8, 0, 13, 0, 15, 1, 7, 0, 0, 0, 14, 0, 19, 0, 19, 0, 15, 0, 18, 0, 19, 1, 22, 0, 11, 1, 8, 0, 7, 1, 15, 0, 23, 0, 23, 0, 11, 0, 11, 0, 8, 1)
nodes/fragment/0/position = Vector2(8260, -1840)
nodes/fragment/17/node = SubResource("8")
nodes/fragment/17/position = Vector2(3100, -840)
nodes/fragment/18/node = SubResource("9")
nodes/fragment/18/position = Vector2(6180, -2280)
nodes/fragment/19/node = SubResource("10")
nodes/fragment/19/position = Vector2(3920, -660)
nodes/fragment/20/node = SubResource("11")
nodes/fragment/20/position = Vector2(2980, -1200)
nodes/fragment/26/node = SubResource("12")
nodes/fragment/26/position = Vector2(3100, -660)
nodes/fragment/33/node = SubResource("13")
nodes/fragment/33/position = Vector2(800, -1660)
nodes/fragment/35/node = SubResource("14")
nodes/fragment/35/position = Vector2(1520, -1660)
nodes/fragment/39/node = SubResource("16")
nodes/fragment/39/position = Vector2(7540, -1640)
nodes/fragment/40/node = SubResource("17")
nodes/fragment/40/position = Vector2(7180, -1840)
nodes/fragment/41/node = SubResource("18")
nodes/fragment/41/position = Vector2(7160, -1460)
nodes/fragment/59/node = SubResource("28")
nodes/fragment/59/position = Vector2(6320, -1820)
nodes/fragment/61/node = SubResource("29")
nodes/fragment/61/position = Vector2(4480, -2340)
nodes/fragment/95/node = SubResource("30")
nodes/fragment/95/position = Vector2(7820, -960)
nodes/fragment/99/node = SubResource("32")
nodes/fragment/99/position = Vector2(6840, -840)
nodes/fragment/100/node = SubResource("1")
nodes/fragment/100/position = Vector2(3040, 380)
nodes/fragment/101/node = SubResource("2")
nodes/fragment/101/position = Vector2(4980, -20)
nodes/fragment/102/node = SubResource("3")
nodes/fragment/102/position = Vector2(4080, 460)
nodes/fragment/103/node = SubResource("4")
nodes/fragment/103/position = Vector2(5480, -220)
nodes/fragment/104/node = SubResource("5")
nodes/fragment/104/position = Vector2(4120, 840)
nodes/fragment/105/node = SubResource("6")
nodes/fragment/105/position = Vector2(5180, 380)
nodes/fragment/106/node = SubResource("7")
nodes/fragment/106/position = Vector2(4760, 820)
nodes/fragment/107/node = SubResource("49")
nodes/fragment/107/position = Vector2(3080, 900)
nodes/fragment/108/node = SubResource("50")
nodes/fragment/108/position = Vector2(4060, 160)
nodes/fragment/109/node = SubResource("VisualShaderNodeTexture2DParameter_vly2v")
nodes/fragment/109/position = Vector2(2480, -840)
nodes/fragment/110/node = SubResource("VisualShaderNodeTexture2DParameter_wo80b")
nodes/fragment/110/position = Vector2(500, -760)
nodes/fragment/111/node = SubResource("VisualShaderNodeTexture_d387j")
nodes/fragment/111/position = Vector2(7760, -1320)
nodes/fragment/125/node = SubResource("VisualShaderNodeVectorDecompose_0baoi")
nodes/fragment/125/position = Vector2(2120, -1700)
nodes/fragment/133/node = SubResource("VisualShaderNodeInput_svam0")
nodes/fragment/133/position = Vector2(2500, -1900)
nodes/fragment/134/node = SubResource("VisualShaderNodeExpression_kf1ub")
nodes/fragment/134/position = Vector2(3040, -1960)
nodes/fragment/134/size = Vector2(792.119, 502.087)
nodes/fragment/134/input_ports = "0,7,matrix;1,0,depth;"
nodes/fragment/134/output_ports = "0,0,linear_depth;"
nodes/fragment/134/expression = "vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, depth);
vec4 view = matrix * vec4(ndc, 1.0);
view.xyz /= view.w;
linear_depth = view.z;"
nodes/fragment/136/node = SubResource("VisualShaderNodeInput_suofc")
nodes/fragment/136/position = Vector2(3260, -2180)
nodes/fragment/137/node = SubResource("VisualShaderNodeVectorDecompose_r5c3m")
nodes/fragment/137/position = Vector2(4060, -2160)
nodes/fragment/138/node = SubResource("VisualShaderNodeFloatOp_xjae2")
nodes/fragment/138/position = Vector2(4600, -1920)
nodes/fragment/139/node = SubResource("VisualShaderNodeFloatOp_f51ga")
nodes/fragment/139/position = Vector2(5220, -1980)
nodes/fragment/140/node = SubResource("VisualShaderNodeFloatOp_msonu")
nodes/fragment/140/position = Vector2(5680, -1980)
nodes/fragment/connections = PackedInt32Array(17, 0, 19, 2, 20, 0, 19, 0, 33, 0, 35, 0, 26, 0, 19, 3, 39, 0, 0, 3, 102, 0, 101, 1, 101, 0, 103, 0, 104, 0, 106, 0, 104, 0, 105, 0, 106, 0, 105, 1, 105, 0, 103, 1, 108, 0, 101, 0, 100, 0, 108, 0, 107, 0, 108, 1, 109, 0, 19, 7, 110, 0, 19, 8, 59, 0, 40, 2, 19, 0, 40, 1, 18, 0, 40, 0, 19, 1, 41, 1, 59, 0, 41, 2, 95, 0, 0, 10, 99, 0, 111, 2, 103, 0, 111, 0, 111, 0, 0, 9, 110, 0, 35, 2, 35, 0, 125, 0, 133, 0, 134, 0, 125, 0, 134, 1, 136, 0, 137, 0, 137, 2, 138, 0, 134, 0, 138, 1, 138, 0, 139, 1, 61, 0, 139, 0, 40, 0, 0, 0, 41, 0, 0, 5, 140, 0, 59, 0, 139, 0, 140, 1)
