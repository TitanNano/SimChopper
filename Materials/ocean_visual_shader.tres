[gd_resource type="VisualShader" load_steps=52 format=2]

[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/common/noise/simplex_3d.gd" type="Script" id=1]
[ext_resource path="res://addons/shaderV/tools/TimeScaled.gd" type="Script" id=2]
[ext_resource path="res://addons/visual_shader_node_library/shader_nodes/3d/screenspace_refraction.gd" type="Script" id=3]
[ext_resource path="res://addons/shaderV/tools/relay.gd" type="Script" id=4]

[sub_resource type="VisualShaderNodeInput" id=1]
output_port_for_preview = 0
input_name = "uv"

[sub_resource type="VisualShaderNodeVectorOp" id=2]
operator = 2

[sub_resource type="VisualShaderNodeScalarUniform" id=3]
uniform_name = "Normal_Resolution"

[sub_resource type="VisualShaderNodeVectorOp" id=4]

[sub_resource type="VisualShaderNodeCustom" id=5]
default_input_values = [ 0, 0.1 ]
initialized = true
script = ExtResource( 2 )

[sub_resource type="VisualShaderNodeVectorCompose" id=6]

[sub_resource type="VisualShaderNodeScalarOp" id=7]
default_input_values = [ 0, 0.0, 1, -1.0 ]
operator = 2

[sub_resource type="VisualShaderNodeScalarConstant" id=8]

[sub_resource type="VisualShaderNodeColorUniform" id=9]
uniform_name = "Albedo"

[sub_resource type="VisualShaderNodeCustom" id=10]
default_input_values = [ 1, 1.0, 2, 0.0, 4, 0.0 ]
initialized = true
script = ExtResource( 3 )

[sub_resource type="VisualShaderNodeScalarUniform" id=11]
uniform_name = "IOR"

[sub_resource type="VisualShaderNodeColorConstant" id=12]
constant = Color( 1, 1, 1, 0 )

[sub_resource type="VisualShaderNodeInput" id=13]
input_name = "screen_uv"

[sub_resource type="VisualShaderNodeTexture" id=14]
source = 4

[sub_resource type="VisualShaderNodeInput" id=15]
input_name = "vertex"

[sub_resource type="VisualShaderNodeScalarConstant" id=16]
constant = 0.3

[sub_resource type="VisualShaderNodeVectorScalarMix" id=17]
default_input_values = [ 0, Vector3( 0, 0, 0 ), 1, Vector3( 1, 1, 1 ), 2, 0.0 ]

[sub_resource type="VisualShaderNodeVectorScalarMix" id=18]
default_input_values = [ 0, Vector3( 0, 0, 0 ), 1, Vector3( 0, 0, 0 ), 2, 0.0 ]

[sub_resource type="VisualShaderNodeVectorOp" id=19]
default_input_values = [ 0, Vector3( 0, 0, 0 ), 1, Vector3( 2, 2, 2 ) ]
operator = 2

[sub_resource type="VisualShaderNodeScalarConstant" id=20]
constant = 2.0

[sub_resource type="VisualShaderNodeVectorOp" id=21]
operator = 1

[sub_resource type="VisualShaderNodeScalarConstant" id=22]
constant = 1.0

[sub_resource type="VisualShaderNodeExpression" id=23]
size = Vector2( 979.327, 608.878 )
expression = "// depth = texture(DEPTH_TEXTURE, SCREEN_UV).r;
// depth = depth * 2.0 - 1.0;

depth_out = matrix[3][2] / (depth + matrix[2][2]);
depth_out += vertex.z;
depth_out = exp(-(depth_out * depth_scale));
//depth_out = 1.0 - depth_out;
"

[sub_resource type="VisualShaderNodeScalarOp" id=24]
default_input_values = [ 0, 0.0, 1, 2.0 ]
operator = 2

[sub_resource type="VisualShaderNodeScalarOp" id=25]
default_input_values = [ 0, 0.0, 1, 1.0 ]
operator = 1

[sub_resource type="VisualShaderNodeInput" id=26]
input_name = "projection"

[sub_resource type="VisualShaderNodeInput" id=27]
input_name = "vertex"

[sub_resource type="VisualShaderNodeScalarClamp" id=28]

[sub_resource type="VisualShaderNodeScalarUniform" id=29]
uniform_name = "Depth_Scale"

[sub_resource type="VisualShaderNodeScalarConstant" id=30]
constant = 1.0

[sub_resource type="VisualShaderNodeCustom" id=31]
initialized = true
script = ExtResource( 4 )

[sub_resource type="VisualShaderNodeTextureUniform" id=32]
uniform_name = "TextureUniform"
texture_type = 2

[sub_resource type="VisualShaderNodeScalarOp" id=33]
default_input_values = [ 0, 0.0, 1, -1.0 ]
operator = 1

[sub_resource type="VisualShaderNodeScalarOp" id=34]
default_input_values = [ 0, 0.0, 1, 2.0 ]
operator = 2

[sub_resource type="VisualShaderNodeScalarConstant" id=35]
constant = 100.0

[sub_resource type="VisualShaderNodeInput" id=36]
input_name = "uv"

[sub_resource type="VisualShaderNodeCustom" id=37]
default_input_values = [ 1, Vector3( 1, 1, 1 ) ]
initialized = true
script = ExtResource( 1 )

[sub_resource type="VisualShaderNodeCustom" id=38]
default_input_values = [ 0, 0.01 ]
initialized = true
script = ExtResource( 2 )

[sub_resource type="VisualShaderNodeVectorOp" id=39]
default_input_values = [ 0, Vector3( 0, 0, 0 ), 1, Vector3( 2, 3, 3 ) ]
operator = 2

[sub_resource type="VisualShaderNodeScalarOp" id=40]
default_input_values = [ 0, 0.0, 1, 3.3 ]
operator = 1

[sub_resource type="VisualShaderNodeScalarUniform" id=47]
uniform_name = "Wave_Height"

[sub_resource type="VisualShaderNodeScalarOp" id=48]
default_input_values = [ 0, 0.0, 1, 1.3 ]

[sub_resource type="VisualShaderNodeInput" id=42]
input_name = "vertex"

[sub_resource type="VisualShaderNodeVectorDecompose" id=43]

[sub_resource type="VisualShaderNodeVectorCompose" id=44]

[sub_resource type="VisualShaderNodeScalarOp" id=45]

[sub_resource type="VisualShaderNodeScalarOp" id=46]
default_input_values = [ 0, 0.0, 1, 2.0 ]
operator = 2

[resource]
code = "shader_type spatial;
render_mode depth_draw_always, specular_schlick_ggx;

uniform float Wave_Height;
uniform vec4 Albedo : hint_color;
uniform float IOR;
uniform float Depth_Scale;
uniform float Normal_Resolution;
uniform sampler2D TextureUniform : hint_normal;


// SimplexNoise3D


// Description : Array and textureless GLSL 2D/3D/4D simplex 
//               noise functions.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : stegu
//     Lastmod : 20110822 (ijm)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
//               https://github.com/stegu/webgl-noise
// 

vec3 HELPER_SimplexNoise3D_mod289_3(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_SimplexNoise3D_mod289_4(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 HELPER_SimplexNoise3D_permute(vec4 x) {
    return HELPER_SimplexNoise3D_mod289_4(((x*34.0)+1.0)*x);
}

vec4 HELPER_SimplexNoise3D_taylorInvSqrt(vec4 r) {
    return 2.79284291400159 - 0.85373472095314 * r;
}

float simplex_noise_3d(vec3 v, out vec3 gradient) {
    vec2 C = vec2(1.0/6.0, 1.0/3.0) ;
    vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
    
    // First corner
    vec3 i  = floor(v + dot(v, vec3(C.y)) );
    vec3 x0 =   v - i + dot(i, vec3(C.x)) ;
    
    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );
    
    //   x0 = x0 - 0.0 + 0.0 * C.xxx;
    //   x1 = x0 - i1  + 1.0 * C.xxx;
    //   x2 = x0 - i2  + 2.0 * C.xxx;
    //   x3 = x0 - 1.0 + 3.0 * C.xxx;
    vec3 x1 = x0 - i1 + vec3(C.x);
    vec3 x2 = x0 - i2 + vec3(C.y); // 2.0*C.x = 1/3 = C.y
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
    
    // Permutations
    i = HELPER_SimplexNoise3D_mod289_3(i); 
    vec4 p = HELPER_SimplexNoise3D_permute( HELPER_SimplexNoise3D_permute( HELPER_SimplexNoise3D_permute( 
    		 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
    	   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
    	   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
    
    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
    float n_ = 0.142857142857; // 1.0/7.0
    vec3  ns = n_ * D.wyz - D.xzx;
    
    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
    
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
    
    vec4 x = x_ *ns.x + vec4(ns.y);
    vec4 y = y_ *ns.x + vec4(ns.y);
    vec4 h = 1.0 - abs(x) - abs(y);
    
    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );
    
    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    
    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww ;
    
    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);
    
    //Normalise gradients
    vec4 norm = HELPER_SimplexNoise3D_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    
    // Mix final noise value
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), vec4(0.0));
    vec4 m2 = m * m;
    vec4 m4 = m2 * m2;
    vec4 pdotx = vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3));
    
    // Determine noise gradient
    vec4 temp = m2 * m * pdotx;
    gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);
    gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;
    gradient *= 42.0;
    
    return 22.0 * dot(m4, pdotx);
}

// ScreenSpaceRefraction

const int SSR_MAX_STEPS = 256;

vec3 line_plane_intersect(vec3 lineorigin, vec3 linedirection, vec3 planeorigin, vec3 planenormal) {
	float dist = dot(planenormal, planeorigin - lineorigin) / dot(planenormal, linedirection);
	return lineorigin + linedirection * dist;
}

float line_unit_box_intersect_dist(vec3 lineorigin, vec3 linedirection) {
  /* https://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/
   */
  vec3 firstplane = (vec3(1.0) - lineorigin) / linedirection;
  vec3 secondplane = (vec3(-1.0) - lineorigin) / linedirection;
  vec3 furthestplane = max(firstplane, secondplane);

  return min(furthestplane.x, min(furthestplane.y, furthestplane.z));
}

vec3 get_specular_refraction_dominant_dir(vec3 N, vec3 V, float ssr_roughness, float ssr_ior) {
	/* TODO: This a bad approximation. Better approximation should fit
	* the refracted vector and ssr_roughness into the best prefiltered reflection
	* lobe. */
	/* Correct the ssr_ior for ssr_ior < 1.0 to not see the abrupt delimitation or the TIR */
	ssr_ior = (ssr_ior < 1.0) ? mix(ssr_ior, 1.0, ssr_roughness) : ssr_ior;
	float eta = 1.0 / ssr_ior;
	
	float NV = dot(N, -V);
	
	/* Custom Refraction. */
	float k = 1.0 - eta * eta * (1.0 - NV * NV);
	k = max(0.0, k); /* Only this changes. */
	vec3 R = eta * -V - (eta * NV + sqrt(k)) * N;
	
	return R;
}

vec3 project_point(mat4 projection_matrix, vec3 point) {
	vec4 ndc = projection_matrix * vec4(point, 1.0);
	return ndc.xyz / ndc.w;
}

float F_eta(float eta, float cos_theta) {
	/* compute fresnel reflectance without explicitly computing
	* the refracted direction */
	float c = abs(cos_theta);
	float g = eta * eta - 1.0 + c * c;
	float result;
	
	if (g > 0.0) {
		g = sqrt(g);
		vec2 g_c = vec2(g) + vec2(c, -c);
		float A = g_c.y / g_c.x;
		A *= A;
		g_c *= c;
		float B = (g_c.y - 1.0) / (g_c.x + 1.0);
		B *= B;
		result = 0.5 * A * (1.0 + B);
	} else {
		result = 1.0; /* TIR (no refracted component) */
	}
	
	return result;
}

void prepare_raycast(mat4 projection_matrix, vec3 ray_origin, vec3 ray_dir, float ssr_thickness, vec2 pixel_size, out vec4 ss_step, out vec4 ss_ray, out float max_time) {
	/* Negate the ray direction if it goes towards the camera.
	* This way we don't need to care if the projected point
	* is behind the near plane. */
	float z_sign = -sign(ray_dir.z);
	vec3 ray_end = ray_origin + z_sign * ray_dir;
	
	/* Project into screen space. */
	vec4 ss_start, ss_end;
	ss_start.xyz = project_point(projection_matrix, ray_origin);
	ss_end.xyz = project_point(projection_matrix, ray_end);
	
	/* We interpolate the ray Z + ssr_thickness values to check if depth is within threshold. */
	ray_origin.z -= ssr_thickness;
	ray_end.z -= ssr_thickness;
	ss_start.w = project_point(projection_matrix, ray_origin).z;
	ss_end.w = project_point(projection_matrix, ray_end).z;
	
	/* XXX This is a hack. A better method is welcome! */
	/* We take the delta between the offsetted depth and the depth and subtract it from the ray
	* depth. This will change the world space ssr_thickness appearance a bit but we can have negative
	* values without worries. We cannot do this in viewspace because of the perspective division. */
	ss_start.w = 2.0 * ss_start.z - ss_start.w;
	ss_end.w = 2.0 * ss_end.z - ss_end.w;
	
	ss_step = ss_end - ss_start;
	max_time = length(ss_step.xyz);
	ss_step = z_sign * ss_step / length(ss_step.xyz);
	
	/* If the line is degenerate, make it cover at least one pixel
	* to not have to handle zero-pixel extent as a special case later */
	ss_step.xy += vec2((dot(ss_step.xy, ss_step.xy) < 0.00001) ? 0.001 : 0.0);
	
	/* Make ss_step cover one pixel. */
	ss_step /= max(abs(ss_step.x), abs(ss_step.y));
	ss_step *= (abs(ss_step.x) > abs(ss_step.y)) ? pixel_size.x : pixel_size.y;
	
	/* Clip to segment's end. */
	max_time /= length(ss_step.xyz);
	
	/* Clipping to frustum sides. */
	max_time = min(max_time, line_unit_box_intersect_dist(ss_start.xyz, ss_step.xyz));
	
	/* Convert to texture coords. Z component included
	* since this is how it's stored in the depth buffer.
	* 4th component how far we are on the ray */
	ss_ray = ss_start * 0.5 + 0.5;
	ss_step *= 0.5;
	
	/* take the center of the texel. */
}

// #define GROUPED_FETCHES /* is still slower, need to see where is the bottleneck. */
/* Return the hit position, and negate the z component (making it positive) if not hit occurred. */
/* __ray_dir__ is the ray direction premultiplied by it's maximum length */
vec3 raycast(mat4 projection_matrix, sampler2D depth_texture, vec3 ray_origin, vec3 ray_dir, float ssr_thickness, float ray_jitter, float trace_quality, float ssr_roughness, bool discard_backface) {
	vec4 ss_step, ss_start;
	float max_time;
	prepare_raycast(projection_matrix, ray_origin, ray_dir, ssr_thickness, 1.0 / vec2(textureSize(depth_texture, 0)), ss_step, ss_start, max_time);
	
	float max_trace_time = max(0.01, max_time - 0.01);
	
	/* x : current_time, y: previous_time, z: current_delta, w: previous_delta */
	vec4 times_and_deltas = vec4(0.0);
	
	float ray_time = 0.0;
	float depth_sample = textureLod(depth_texture, ss_start.xy, 0.0).x;
	times_and_deltas.z = depth_sample - ss_start.z;
	
	float lod_fac = clamp(sqrt(ssr_roughness) * 2.0 - 0.4, 0.0, 1.0);
	bool hit = false;
	float iter;
	for(iter = 1.0; !hit && (ray_time < max_time) && (iter < float(SSR_MAX_STEPS)); iter++) {
		/* Minimum stride of 2 because we are using half res minmax zbuffer. */
		float stride = max(1.0, iter * trace_quality) * 2.0;
		float lod = log2(stride * 0.5 * trace_quality) * lod_fac;
		ray_time += stride;
		
		/* Save previous values. */
		times_and_deltas.xyzw = times_and_deltas.yxwz;
		
		float jit_stride = mix(2.0, stride, ray_jitter);
		
		times_and_deltas.x = min(ray_time + jit_stride, max_trace_time);
		vec4 ss_ray = ss_start + ss_step * times_and_deltas.x;
		
		depth_sample = textureLod(depth_texture, ss_ray.xy, lod).x;
		
		float prev_w = ss_start.w + ss_step.w * times_and_deltas.y;
		times_and_deltas.z = depth_sample - ss_ray.z;
		hit = (times_and_deltas.z <= 0.0) && (prev_w <= depth_sample);
	}
	
	if (discard_backface) {
		/* Discard backface hits */
		hit = hit && (times_and_deltas.w > 0.0);
	}
	
	/* Reject hit if background. */
	hit = hit && (depth_sample != 1.0);
	
	times_and_deltas.x = hit ? mix(times_and_deltas.y, times_and_deltas.x, clamp(times_and_deltas.w / (times_and_deltas.w - times_and_deltas.z), 0.0, 1.0)) : times_and_deltas.x;
	ray_time = hit ? times_and_deltas.x : ray_time;
	
	/* Clip to frustum. */
	ray_time = max(0.001, min(ray_time, max_time - 1.5));
	
	vec4 ss_ray = ss_start + ss_step * ray_time;
	
	/* Tag Z if ray failed. */
//	ss_ray.z *= (hit) ? 1.0 : -1.0;
	return ss_ray.xyz;
}

float screen_border_mask(vec2 hit_co) {
	const float ssrBorderFac = 0.1;
	
	const float margin = 0.003;
	float atten = ssrBorderFac + margin; /* Screen percentage */
	hit_co = smoothstep(margin, atten, hit_co) * (1.0 - smoothstep(1.0 - atten, 1.0 - margin, hit_co));
	float screenfade = hit_co.x * hit_co.y;
	return screenfade;
}

vec4 ssr(vec3 position, mat4 projection_matrix, mat4 view_matrix, sampler2D screen_texture, sampler2D depth_texture, vec3 N, vec3 V, float ssr_ior, float ssr_roughnessSquared) {
	float a2 = max(5e-6, ssr_roughnessSquared * ssr_roughnessSquared);
	
	vec3 H = N;
	float pdf = 0.0;
	
	vec3 vV = V;
	float eta = 1.0 / ssr_ior;
	if (dot(H, V) < 0.0) {
		H = -H;
		eta = ssr_ior;
	}
	
	vec3 R = refract(-V, H, 1.0 / ssr_ior);
	
	R = (view_matrix * vec4(R, 0.0)).xyz;
	
	const float ssrssr_thickness = 1.0;
	const float ssrQuality = 0.0;
	
	vec3 hit_pos = raycast(projection_matrix, depth_texture, position, R * 1e16, ssrssr_thickness, 0.0, ssrQuality, ssr_roughnessSquared, false);
	
	if ((hit_pos.z > 0.0) && (F_eta(ssr_ior, dot(H, V)) < 1.0)) {
		vec2 hit_uvs = project_point(projection_matrix, hit_pos).xy * 0.5 + 0.5;
		
		vec3 spec = textureLod(screen_texture, hit_pos.xy, ssr_roughnessSquared * 8.0).xyz;
		float mask = screen_border_mask(hit_uvs);
		return vec4(spec, mask);
	}
	
	return vec4(0.0);
}

void screenspace_refraction(in float ssr_ior, in float ssr_roughness, in float ssr_thickness, in vec3 albedo_in, in float alpha_in, in vec3 emission_in, in vec2 screen_uv, in sampler2D screen_texture, in sampler2D depth_texture, in vec3 view, in vec3 normal, in vec3 position, in mat4 view_matrix, in mat4 camera_matrix, in mat4 projection_matrix, out vec3 albedo_out, out vec3 emission_out) { 
	vec3 V = (camera_matrix * vec4(view, 0.0)).xyz;
	vec3 N = (camera_matrix * vec4(normal, 0.0)).xyz;
	vec3 world_pos = (camera_matrix * vec4(position, 1.0)).xyz;
	
	/* Refract the view vector using the depth heuristic.
	* Then later Refract a second time the already refracted
	* ray using the inverse ssr_ior. */
	float final_ior = (ssr_thickness > 0.0) ? 1.0 / ssr_ior : ssr_ior;
	vec3 refr_V = (ssr_thickness > 0.0) ? -refract(-V, N, final_ior) : V;
	vec3 refr_pos = (ssr_thickness > 0.0) ?
			line_plane_intersect(world_pos, refr_V, world_pos - N * ssr_thickness, N) :
			world_pos;
	vec3 refr_dir = get_specular_refraction_dominant_dir(N, refr_V, ssr_roughness, final_ior);
	
	/* ---------------------------- */
	/*   Screen Space Refraction    */
	/* ---------------------------- */
	/* Find approximated position of the 2nd refraction event. */
	vec3 refr_vpos = (ssr_thickness > 0.0) ? (view_matrix * vec4(refr_pos, 1.0)).xyz :
			position;
	vec4 trans = ssr(refr_vpos, projection_matrix, view_matrix, screen_texture, depth_texture, N, refr_V, final_ior, ssr_roughness * ssr_roughness);
	trans.a *= smoothstep(1.0 + 0.2, 1.0, ssr_roughness);
	
	float fac = 1.0 - alpha_in;
	fac *= 1.0 - pow(1.0 - dot(V, N), 5.0) * (1.0 - ssr_roughness);
	
	emission_out = emission_in + trans.rgb * albedo_in * fac;
	albedo_out = albedo_in * 1.0 - fac;
}


void vertex() {
// Input:5
	vec3 n_out5p0 = VERTEX;

// VectorDecompose:6
	float n_out6p0 = n_out5p0.x;
	float n_out6p1 = n_out5p0.y;
	float n_out6p2 = n_out5p0.z;

// Input:14
	vec3 n_out14p0 = vec3(UV, 0.0);

// ScaledTIME:18
	float n_in18p0 = 0.01000;
	float n_out18p0;
	{
		n_out18p0 = n_in18p0 * TIME;
	}

// VectorOp:19
	vec3 n_out19p0 = n_out14p0 * vec3(n_out18p0);

// Scalar:13
	float n_out13p0 = 100.000000;

// SimplexNoise3D:15
	float n_out15p0;
	vec3 n_out15p1;
	{
		
				n_out15p0 = simplex_noise_3d(n_out19p0 * vec3(n_out13p0), n_out15p1);
			
	}

// ScalarOp:9
	float n_in9p1 = 2.00000;
	float n_out9p0 = n_out15p0 * n_in9p1;

// ScalarOp:10
	float n_in10p1 = -1.00000;
	float n_out10p0 = n_out9p0 - n_in10p1;

// ScalarUniform:22
	float n_out22p0 = Wave_Height;

// ScalarOp:11
	float n_out11p0 = n_out10p0 * n_out22p0;

// ScalarOp:8
	float n_out8p0 = n_out6p1 + n_out11p0;

// ScalarOp:23
	float n_in23p1 = 1.30000;
	float n_out23p0 = n_out22p0 + n_in23p1;

// ScalarOp:20
	float n_out20p0 = n_out8p0 - n_out23p0;

// VectorCompose:7
	vec3 n_out7p0 = vec3(n_out6p0, n_out20p0, n_out6p2);

// Output:0
	VERTEX = n_out7p0;

}

void fragment() {
// ColorUniform:18
	vec3 n_out18p0 = Albedo.rgb;
	float n_out18p1 = Albedo.a;

// ScalarUniform:20
	float n_out20p0 = IOR;

// Scalar:17
	float n_out17p0 = 0.000000;

// Color:26
	vec3 n_out26p0 = vec3(1.000000, 1.000000, 1.000000);
	float n_out26p1 = 0.000000;

// ScreenSpaceRefraction:19
	float n_in19p1 = 1.00000;
	vec3 n_out19p0;
	vec3 n_out19p1;
	{
		screenspace_refraction(n_out20p0, n_out17p0, n_in19p1, n_out26p0, n_out26p1, vec3(0.0), SCREEN_UV, SCREEN_TEXTURE, DEPTH_TEXTURE, VIEW, NORMAL, VERTEX, INV_CAMERA_MATRIX, CAMERA_MATRIX, PROJECTION_MATRIX, n_out19p0, n_out19p1);
	}

// Input:57
	vec3 n_out57p0 = VERTEX;

// Input:33
	vec3 n_out33p0 = vec3(SCREEN_UV, 0.0);

// Texture:35
	float n_out35p0;
	float n_out35p1;
	{
		float _depth = texture(DEPTH_TEXTURE, n_out33p0.xy).r;
		n_out35p0 = _depth;
		n_out35p1 = 1.0;
	}

// ScalarOp:50
	float n_in50p1 = 2.00000;
	float n_out50p0 = n_out35p0 * n_in50p1;

// ScalarOp:51
	float n_in51p1 = 1.00000;
	float n_out51p0 = n_out50p0 - n_in51p1;

// Input:56
	mat4 n_out56p0 = PROJECTION_MATRIX;

// ScalarUniform:61
	float n_out61p0 = Depth_Scale;

// Expression:49
	float n_out49p0;
	n_out49p0 = 0.0;
	{
		// n_out51p0 = texture(DEPTH_TEXTURE, SCREEN_UV).r;
		// n_out51p0 = n_out51p0 * 2.0 - 1.0;
		
		n_out49p0 = n_out56p0[3][2] / (n_out51p0 + n_out56p0[2][2]);
		n_out49p0 += n_out57p0.z;
		n_out49p0 = exp(-(n_out49p0 * n_out61p0));
		//n_out49p0 = 1.0 - n_out49p0;
		
	}

// ScalarClamp:59
	float n_in59p1 = 0.00000;
	float n_in59p2 = 1.00000;
	float n_out59p0 = clamp(n_out49p0, n_in59p1, n_in59p2);

// VectorScalarMix:40
	vec3 n_out40p0 = mix(n_out18p0, n_out19p0, n_out59p0);

// Relay:96
	vec3 n_out96p0;
	{
		n_out96p0 = n_out40p0
	}

// Scalar:39
	float n_out39p0 = 0.300000;

// VectorScalarMix:41
	vec3 n_in41p0 = vec3(0.00000, 0.00000, 0.00000);
	vec3 n_out41p0 = mix(n_in41p0, n_out19p1, n_out59p0);

// Input:100
	vec3 n_out100p0 = vec3(UV, 0.0);

// ScalarUniform:102
	float n_out102p0 = Normal_Resolution;

// VectorOp:101
	vec3 n_out101p0 = n_out100p0 * vec3(n_out102p0);

// ScaledTIME:104
	float n_in104p0 = 0.10000;
	float n_out104p0;
	{
		n_out104p0 = n_in104p0 * TIME;
	}

// ScalarOp:106
	float n_in106p1 = -1.00000;
	float n_out106p0 = n_out104p0 * n_in106p1;

// VectorCompose:105
	float n_in105p2 = 0.00000;
	vec3 n_out105p0 = vec3(n_out104p0, n_out106p0, n_in105p2);

// VectorOp:103
	vec3 n_out103p0 = n_out101p0 + n_out105p0;

// TextureUniform:99
	vec3 n_out99p0;
	float n_out99p1;
	{
		vec4 n_tex_read = texture(TextureUniform, n_out103p0.xy);
		n_out99p0 = n_tex_read.rgb;
		n_out99p1 = n_tex_read.a;
	}

// Scalar:95
	float n_out95p0 = 1.000000;

// Output:0
	ALBEDO = n_out96p0;
	ROUGHNESS = n_out39p0;
	EMISSION = n_out41p0;
	NORMALMAP = n_out99p0;
	NORMALMAP_DEPTH = n_out95p0;

}

void light() {
// Output:0

}
"
graph_offset = Vector2( 57.8729, -67.4554 )
modes/depth_draw = 1
nodes/vertex/0/position = Vector2( 2440, -460 )
nodes/vertex/5/node = SubResource( 42 )
nodes/vertex/5/position = Vector2( -560, -120 )
nodes/vertex/6/node = SubResource( 43 )
nodes/vertex/6/position = Vector2( -140, -240 )
nodes/vertex/7/node = SubResource( 44 )
nodes/vertex/7/position = Vector2( 1960, -380 )
nodes/vertex/8/node = SubResource( 45 )
nodes/vertex/8/position = Vector2( 1080, -340 )
nodes/vertex/9/node = SubResource( 46 )
nodes/vertex/9/position = Vector2( -120, 80 )
nodes/vertex/10/node = SubResource( 33 )
nodes/vertex/10/position = Vector2( 300, 20 )
nodes/vertex/11/node = SubResource( 34 )
nodes/vertex/11/position = Vector2( 660, -80 )
nodes/vertex/13/node = SubResource( 35 )
nodes/vertex/13/position = Vector2( -1060, 420 )
nodes/vertex/14/node = SubResource( 36 )
nodes/vertex/14/position = Vector2( -1840, -120 )
nodes/vertex/15/node = SubResource( 37 )
nodes/vertex/15/position = Vector2( -580, 120 )
nodes/vertex/18/node = SubResource( 38 )
nodes/vertex/18/position = Vector2( -2080, 300 )
nodes/vertex/19/node = SubResource( 39 )
nodes/vertex/19/position = Vector2( -1420, 0 )
nodes/vertex/20/node = SubResource( 40 )
nodes/vertex/20/position = Vector2( 1500, -160 )
nodes/vertex/22/node = SubResource( 47 )
nodes/vertex/22/position = Vector2( 300, 300 )
nodes/vertex/23/node = SubResource( 48 )
nodes/vertex/23/position = Vector2( 1120, -80 )
nodes/vertex/connections = PoolIntArray( 5, 0, 6, 0, 6, 0, 7, 0, 6, 2, 7, 2, 9, 0, 10, 0, 10, 0, 11, 0, 11, 0, 8, 1, 6, 1, 8, 0, 13, 0, 15, 1, 15, 0, 9, 0, 7, 0, 0, 0, 14, 0, 19, 0, 19, 0, 15, 0, 18, 0, 19, 1, 8, 0, 20, 0, 20, 0, 7, 1, 22, 0, 11, 1, 22, 0, 23, 0, 23, 0, 20, 1 )
nodes/fragment/0/position = Vector2( 5780, -880 )
nodes/fragment/17/node = SubResource( 8 )
nodes/fragment/17/position = Vector2( 1740, -120 )
nodes/fragment/18/node = SubResource( 9 )
nodes/fragment/18/position = Vector2( 3900, -860 )
nodes/fragment/19/node = SubResource( 10 )
nodes/fragment/19/position = Vector2( 2560, -140 )
nodes/fragment/20/node = SubResource( 11 )
nodes/fragment/20/position = Vector2( 1760, -260 )
nodes/fragment/26/node = SubResource( 12 )
nodes/fragment/26/position = Vector2( 1820, 60 )
nodes/fragment/33/node = SubResource( 13 )
nodes/fragment/33/position = Vector2( 840, -1520 )
nodes/fragment/35/node = SubResource( 14 )
nodes/fragment/35/position = Vector2( 1420, -1140 )
nodes/fragment/37/node = SubResource( 15 )
nodes/fragment/37/position = Vector2( 2620, -320 )
nodes/fragment/39/node = SubResource( 16 )
nodes/fragment/39/position = Vector2( 5060, -680 )
nodes/fragment/40/node = SubResource( 17 )
nodes/fragment/40/position = Vector2( 4600, -860 )
nodes/fragment/41/node = SubResource( 18 )
nodes/fragment/41/position = Vector2( 4680, -500 )
nodes/fragment/44/node = SubResource( 19 )
nodes/fragment/44/position = Vector2( 2080, -1600 )
nodes/fragment/45/node = SubResource( 20 )
nodes/fragment/45/position = Vector2( 1480, -1460 )
nodes/fragment/46/node = SubResource( 21 )
nodes/fragment/46/position = Vector2( 2480, -1620 )
nodes/fragment/47/node = SubResource( 22 )
nodes/fragment/47/position = Vector2( 1980, -1340 )
nodes/fragment/49/node = SubResource( 23 )
nodes/fragment/49/position = Vector2( 3040, -1540 )
nodes/fragment/49/size = Vector2( 979.327, 608.878 )
nodes/fragment/49/input_ports = "0,1,vertex;1,0,depth;2,3,matrix;3,0,depth_scale;"
nodes/fragment/49/output_ports = "0,0,depth_out;"
nodes/fragment/49/expression = "// depth = texture(DEPTH_TEXTURE, SCREEN_UV).r;
// depth = depth * 2.0 - 1.0;

depth_out = matrix[3][2] / (depth + matrix[2][2]);
depth_out += vertex.z;
depth_out = exp(-(depth_out * depth_scale));
//depth_out = 1.0 - depth_out;
"
nodes/fragment/50/node = SubResource( 24 )
nodes/fragment/50/position = Vector2( 2020, -1160 )
nodes/fragment/51/node = SubResource( 25 )
nodes/fragment/51/position = Vector2( 2480, -1360 )
nodes/fragment/56/node = SubResource( 26 )
nodes/fragment/56/position = Vector2( 2480, -1120 )
nodes/fragment/57/node = SubResource( 27 )
nodes/fragment/57/position = Vector2( 2620, -1740 )
nodes/fragment/59/node = SubResource( 28 )
nodes/fragment/59/position = Vector2( 4100, -1140 )
nodes/fragment/61/node = SubResource( 29 )
nodes/fragment/61/position = Vector2( 2480, -980 )
nodes/fragment/95/node = SubResource( 30 )
nodes/fragment/95/position = Vector2( 5180, -240 )
nodes/fragment/96/node = SubResource( 31 )
nodes/fragment/96/position = Vector2( 5060, -940 )
nodes/fragment/99/node = SubResource( 32 )
nodes/fragment/99/position = Vector2( 4740, -200 )
nodes/fragment/100/node = SubResource( 1 )
nodes/fragment/100/position = Vector2( 3160, -20 )
nodes/fragment/101/node = SubResource( 2 )
nodes/fragment/101/position = Vector2( 3740, -20 )
nodes/fragment/102/node = SubResource( 3 )
nodes/fragment/102/position = Vector2( 3140, 360 )
nodes/fragment/103/node = SubResource( 4 )
nodes/fragment/103/position = Vector2( 4300, -40 )
nodes/fragment/104/node = SubResource( 5 )
nodes/fragment/104/position = Vector2( 2640, 620 )
nodes/fragment/105/node = SubResource( 6 )
nodes/fragment/105/position = Vector2( 3740, 320 )
nodes/fragment/106/node = SubResource( 7 )
nodes/fragment/106/position = Vector2( 3320, 580 )
nodes/fragment/connections = PoolIntArray( 17, 0, 19, 2, 20, 0, 19, 0, 26, 1, 19, 4, 33, 0, 35, 0, 33, 0, 44, 0, 45, 0, 44, 1, 44, 0, 46, 0, 47, 0, 46, 1, 50, 0, 51, 0, 51, 0, 49, 1, 56, 0, 49, 2, 57, 0, 49, 0, 35, 0, 50, 0, 19, 1, 41, 1, 26, 0, 19, 3, 49, 0, 59, 0, 61, 0, 49, 3, 39, 0, 0, 3, 19, 0, 40, 1, 40, 0, 96, 0, 96, 0, 0, 0, 18, 0, 40, 0, 59, 0, 40, 2, 41, 0, 0, 5, 59, 0, 41, 2, 95, 0, 0, 9, 99, 0, 0, 8, 100, 0, 101, 0, 102, 0, 101, 1, 101, 0, 103, 0, 103, 0, 99, 0, 104, 0, 106, 0, 104, 0, 105, 0, 106, 0, 105, 1, 105, 0, 103, 1 )
