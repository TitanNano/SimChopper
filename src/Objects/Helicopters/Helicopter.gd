extends RigidBody3D

const DustParticles := preload("res://src/Objects/Particles/DustParticles.gd")
const AudioSource := preload("res://src/Objects/Audio/AudioSource.gd")

# pseudo constants
@export var CRUISE_SPEED := 159.0 # km/h
@export var RATE_OF_CLIMB := 3.8 # m/s
@export var RATE_OF_ROTATION := 90 # degrees / s
const MAX_TILT := 45.0 # degrees
const ACCELERATION_TIME := 0.4 # amount of seconds to accelerate to top speed
var CRUISE_SPEED_MS := (CRUISE_SPEED * 1000) / 3600
var DIRECTIONAL_ACCELERATION := CRUISE_SPEED_MS / ACCELERATION_TIME
var ROTATIONAL_ACCELERATION := RATE_OF_ROTATION / ACCELERATION_TIME

var directional_velocity := Vector3.ZERO
var rotational_velocity := 0.0
var engine_speed := 0.0


@onready var audio_fx: AudioSource = $AudioFx
@onready var dust_particles: DustParticles = $Dust
@onready var rotor = $rotor
@onready var camera = $CameraInterpolation


# Called when the node enters the scene tree for the first time.
func _ready():
	self.rotor.power = 0

func _get_top_speed(delta: float) -> float:
	return CRUISE_SPEED_MS * delta


func _get_top_rotation(delta: float) -> float:
	return deg_to_rad(RATE_OF_ROTATION) * delta


func _update_directional_velocity(direction: Vector3, state: PhysicsDirectBodyState3D) -> Vector3:
	var acceleration := DIRECTIONAL_ACCELERATION #* delta
	var y_velocity := Vector3.UP * state.linear_velocity

	var target_velocity = (direction * CRUISE_SPEED_MS) #+ y_velocity

	return state.linear_velocity.move_toward(target_velocity, acceleration)


func _update_rotational_velocity(direction: float, delta: float) -> float:
	var acceleration := deg_to_rad(ROTATIONAL_ACCELERATION) * delta

	if direction == 0:
		self.rotational_velocity = move_toward(self.rotational_velocity, 0, acceleration)
		return self.rotational_velocity

	var target_velocity := self._get_top_rotation(1) * direction
	self.rotational_velocity = move_toward(self.rotational_velocity, target_velocity, acceleration)

	return self.rotational_velocity


func _get_tilt(velocity: Vector3) -> Vector3:
	var top_speed := self._get_top_speed(1)
	var direction := velocity.rotated(Vector3.UP, -self.rotation.y) # revert rotation
	var tilt_z = MAX_TILT * (-direction.x / top_speed)
	var tilt_x = MAX_TILT * (direction.z / top_speed)
	var tilt := Vector3(deg_to_rad(tilt_x), 0, deg_to_rad(tilt_z))

	return tilt


func _physics_process(_delta: float) -> void:
	var ray_cast: RayCast3D = $RayCast3D;
	var ground := ray_cast.get_collision_point()
	var colliding := ray_cast.is_colliding()

	ray_cast.target_position = Vector3.DOWN * 7 * ray_cast.global_transform.basis

	self.rotor.power = self.engine_speed
	self.dust_particles.strength = self.engine_speed if colliding else 0.0

	if colliding:
		self.dust_particles.global_transform.origin = ground


func _integrate_forces(state: PhysicsDirectBodyState3D) -> void:
	var delta := state.step
	var land_strength := Input.get_action_strength("land")
	var climb_strength := Input.get_axis("land", "rise")
	var climb := (RATE_OF_CLIMB) * (climb_strength if climb_strength > land_strength else land_strength * -1)

	var movement_strength := Input.get_axis("forward", "back")
	var turn_strength := Input.get_axis("turn_right", "turn_left")
	var direction := Vector3(-turn_strength, 0, movement_strength).normalized()

	if self.engine_speed < 1:
		if self.engine_speed > 0 and not audio_fx.playing:
			audio_fx.play_track(preload("res://resources/Sounds/Helicopter/start.wav"))

		self.engine_speed = min(self.engine_speed + climb * 0.001, 1)
		return

	if audio_fx.track_name.ends_with("start.wav"):
		var sfx: AudioStreamWAV = preload("res://resources/Sounds/Helicopter/loop0.wav")

		sfx.loop_mode = AudioStreamWAV.LOOP_FORWARD
		sfx.loop_end = sfx.data.size()

		audio_fx.play_track(sfx)

	# apply climb first
	var target_climb_velocity := Vector3(0, climb, 0) + (state.total_gravity * -1)

	if direction.z == 0:
		direction = Vector3.ZERO

	direction = direction.rotated(Vector3.UP, self.rotation.y)

	@warning_ignore("shadowed_variable")
	var directional_velocity := self._update_directional_velocity(direction, state)

	# we calculate the velocity difference between what we target and what we actually got
	var required_force := ((directional_velocity + target_climb_velocity) - state.linear_velocity) * self.mass

	state.apply_central_force(required_force)

	# apply rotational velocity
	@warning_ignore("incompatible_ternary")
	var target_rotation_velocity: float = (self._update_rotational_velocity(turn_strength, delta) if direction == Vector3.ZERO else 0)
	var rotation_velocity := self.global_transform.basis.y * target_rotation_velocity

	# apply tilt due to linear velocity generated by the engine
	var target_tilt := self._get_tilt(directional_velocity)
	var tilt_offset := target_tilt - (self.rotation * (Vector3.RIGHT + Vector3.BACK))
	var tilt_velocity_x := (tilt_offset.x * self.global_transform.basis.x)
	var tilt_velocity_z := (tilt_offset.z * self.global_transform.basis.z)

	var torque_offset := tilt_velocity_x + tilt_velocity_z * 10 + rotation_velocity - state.angular_velocity
	var torque_impulse := self.get_inverse_inertia_tensor().inverse() * torque_offset

	state.apply_torque_impulse(torque_impulse)


func snap_camera():
	self.camera.snap = true
